diff -Nur a/project/cmake/modules/FindX.cmake b/project/cmake/modules/FindX.cmake
--- a/project/cmake/modules/FindX.cmake	2017-05-24 16:49:32.000000000 -0400
+++ b/project/cmake/modules/FindX.cmake	2017-09-29 15:39:08.849365892 -0400
@@ -16,7 +16,7 @@
 #   X::Xext - The X11 extension library
 
 if(PKG_CONFIG_FOUND)
-  pkg_check_modules(PC_X x11 xext QUIET)
+  pkg_check_modules(PC_X x11 xext xrandr QUIET)
 endif()
 
 find_path(X_INCLUDE_DIR NAMES X11/Xlib.h
@@ -25,6 +25,8 @@
                        PATHS ${PC_X_x11_LIBDIR})
 find_library(X_EXT_LIBRARY NAMES Xext
                            PATHS ${PC_X_xext_LIBDIR})
+find_library(X_RANDR_LIBRARY NAMES Xrandr
+                           PATHS ${PC_X_xrandr_LIBDIR})
 
 set(X_VERSION ${PC_X_x11_VERSION})
 
@@ -34,7 +36,7 @@
                                   VERSION_VAR X_VERSION)
 
 if(X_FOUND)
-  set(X_LIBRARIES ${X_LIBRARY} ${X_EXT_LIBRARY})
+  set(X_LIBRARIES ${X_LIBRARY} ${X_EXT_LIBRARY} ${X_RANDR_LIBRARY})
   set(X_INCLUDE_DIRS ${X_INCLUDE_DIR})
   set(X_DEFINITIONS -DHAVE_X11=1)
 
@@ -52,6 +54,13 @@
                                   INTERFACE_INCLUDE_DIRECTORIES "${X_INCLUDE_DIR}"
                                   INTERFACE_LINK_LIBRARIES X::X)
   endif()
+  if(NOT TARGET X::Xrandr)
+    add_library(X::Xrandr UNKNOWN IMPORTED)
+    set_target_properties(X::Xrandr PROPERTIES
+                                    IMPORTED_LOCATION "${X_RANDR_LIBRARY}"
+                                    INTERFACE_INCLUDE_DIRECTORIES "${X_INCLUDE_DIR}"
+                                    INTERFACE_LINK_LIBRARIES X::X)
+  endif()
 endif()
 
 mark_as_advanced(X_INCLUDE_DIR X_LIBRARY X_EXT_LIBRARY)
diff -Nur a/project/cmake/scripts/common/ArchSetup.cmake b/project/cmake/scripts/common/ArchSetup.cmake
--- a/project/cmake/scripts/common/ArchSetup.cmake	2017-05-24 16:49:32.000000000 -0400
+++ b/project/cmake/scripts/common/ArchSetup.cmake	2017-09-29 14:21:59.883600167 -0400
@@ -150,6 +150,14 @@
   endif()
 endif()
 
+if(NOT DEFINED MFC OR MFC)
+  option(ENABLE_MFC "Enable MFC Exynos4/5 codec" ${MFC})
+  if(ENABLE_MFC)
+    message(STATUS "MFC Exynos4/5 codec enabled")
+    list(APPEND SYSTEM_DEFINES -DHAS_MFC=1)
+  endif()
+endif()
+
 if(CMAKE_BUILD_TYPE STREQUAL "Debug")
   add_options (ALL_LANGUAGES DEBUG "-g" "-D_DEBUG" "-Wall")
 endif()
diff -Nur a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp	2017-09-29 14:35:44.271020874 -0400
@@ -41,6 +41,9 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "platform/android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_MFC)
+#include "Video/DVDVideoCodecMFC.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -149,6 +152,8 @@
     pCodec = OpenCodec(new CDVDVideoCodecOpenMax(processInfo), hint, options);
 #elif defined(HAS_MMAL)
     pCodec = OpenCodec(new CMMALVideo(processInfo), hint, options);
+#elif defined(HAS_MFC)
+    pCodec = OpenCodec(new CDVDVideoCodecMFC(processInfo), hint, options);
 #endif
     if (pCodec)
       return pCodec;
diff -Nur a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/CMakeLists.txt	2017-09-29 14:23:06.360108018 -0400
@@ -16,6 +16,11 @@
                       DVDVideoCodecAmlogic.h)
 endif()
 
+if(ENABLE_MFC)
+  list(APPEND SOURCES DVDVideoCodecMFC.cpp)
+  list(APPEND HEADERS DVDVideoCodecMFC.h)
+endif()
+
 if(OPENMAX_FOUND)
   list(APPEND SOURCES DVDVideoCodecOpenMax.cpp
                       OpenMax.cpp
diff -Nur a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.cpp	2017-09-29 14:36:29.775099613 -0400
@@ -0,0 +1,603 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+  #include "DVDDemuxers/DVDDemux.h"
+  #include "DVDStreamInfo.h"
+  #include "DVDClock.h"
+  #include "guilib/GraphicContext.h"
+  #include "DVDCodecs/DVDCodecs.h"
+  #include "DVDCodecs/DVDCodecUtils.h"
+  #include "settings/Settings.h"
+  #include "settings/DisplaySettings.h"
+  #include "settings/AdvancedSettings.h"
+  #include "utils/log.h"
+#endif
+
+#include "DVDVideoCodecMFC.h"
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecMFC"
+
+CDVDVideoCodecMFC::CDVDVideoCodecMFC(CProcessInfo &processInfo) : CDVDVideoCodec(processInfo) {
+
+  m_iDecoderHandle = NULL;
+  m_iConverterHandle = NULL;
+  m_MFCOutput = NULL;
+  m_MFCCapture = NULL;
+  m_FIMCOutput = NULL;
+  m_FIMCCapture = NULL;
+
+  m_Buffer = NULL;
+  m_BufferNowOnScreen = NULL;
+
+  m_droppedFrames = 0;
+  m_codecPts = DVD_NOPTS_VALUE;
+
+  memzero(m_videoBuffer);
+
+}
+
+CDVDVideoCodecMFC::~CDVDVideoCodecMFC() {
+
+  Dispose();
+
+}
+
+bool CDVDVideoCodecMFC::OpenDevices() {
+  DIR *dir;
+
+  if ((dir = opendir ("/sys/class/video4linux/")) != NULL) {
+    struct dirent *ent;
+    while ((ent = readdir (dir)) != NULL) {
+      if (strncmp(ent->d_name, "video", 5) == 0) {
+        char *p;
+        char name[64];
+        char devname[64];
+        char sysname[64];
+        char drivername[32];
+        char target[1024];
+        ssize_t ret;
+
+        snprintf(sysname, 64, "/sys/class/video4linux/%s", ent->d_name);
+        snprintf(name, 64, "/sys/class/video4linux/%s/name", ent->d_name);
+
+        FILE* fp = fopen(name, "r");
+        if (fgets(drivername, 32, fp) != NULL) {
+          p = strchr(drivername, '\n');
+          if (p != NULL)
+            *p = '\0';
+        } else {
+          fclose(fp);
+          continue;
+        }
+        fclose(fp);
+
+        ret = readlink(sysname, target, sizeof(target));
+        if (ret < 0)
+          continue;
+        target[ret] = '\0';
+        p = strrchr(target, '/');
+        if (p == NULL)
+          continue;
+
+        sprintf(devname, "/dev/%s", ++p);
+
+        if (!m_iDecoderHandle && strstr(drivername, "mfc") != NULL && strstr(drivername, "dec") != NULL) {
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > -1) {
+            struct v4l2_capability cap;
+            memzero(cap);
+            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iDecoderHandle = new V4l2Device;
+                m_iDecoderHandle->device = fd;
+                strcpy(m_iDecoderHandle->name, drivername);
+                CLog::Log(LOGDEBUG, "%s::%s - MFC Found %s %s", CLASSNAME, __func__, drivername, devname);
+                struct v4l2_format fmt;
+                memzero(fmt);
+                fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+                fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+                if (ioctl(fd, VIDIOC_TRY_FMT, &fmt) == 0) {
+                  CLog::Log(LOGDEBUG, "%s::%s - Direct decoding to untiled picture on device %s is supported, no conversion needed", CLASSNAME, __func__, m_iDecoderHandle->name);
+                  delete m_iConverterHandle;
+                  m_iConverterHandle = NULL;
+                  return true;
+                }
+              }
+          }
+          if (!m_iDecoderHandle)
+            close(fd);
+        }
+        if (!m_iConverterHandle && strstr(drivername, "fimc") != NULL && strstr(drivername, "m2m") != NULL) {
+          int fd = open(devname, O_RDWR | O_NONBLOCK, 0);
+          if (fd > -1) {
+            struct v4l2_capability cap;
+            memzero(cap);
+            if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == 0)
+              if (cap.capabilities & V4L2_CAP_STREAMING &&
+                (cap.capabilities & V4L2_CAP_VIDEO_M2M_MPLANE ||
+                (cap.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_OUTPUT_MPLANE)))) {
+                m_iConverterHandle = new V4l2Device;
+                m_iConverterHandle->device = fd;
+                strcpy(m_iConverterHandle->name, drivername);
+                CLog::Log(LOGDEBUG, "%s::%s - FIMC Found %s %s", CLASSNAME, __func__, drivername, devname);
+              }
+          }
+          if (!m_iConverterHandle)
+            close(fd);
+        }
+        if (m_iDecoderHandle && m_iConverterHandle) {
+          closedir (dir);
+          return true;
+        }
+      }
+    }
+    closedir (dir);
+  }
+
+  return false;
+
+}
+
+void CDVDVideoCodecMFC::Dispose() {
+
+  CLog::Log(LOGDEBUG, "%s::%s - Starting cleanup", CLASSNAME, __func__);
+
+  delete m_BufferNowOnScreen;
+  delete m_Buffer;
+
+  m_Buffer = NULL;
+  m_BufferNowOnScreen = NULL;
+
+  delete m_FIMCCapture;
+  delete m_FIMCOutput;
+  delete m_MFCCapture;
+  delete m_MFCOutput;
+
+  m_MFCOutput = NULL;
+  m_MFCCapture = NULL;
+  m_FIMCOutput = NULL;
+  m_FIMCCapture = NULL;
+
+  if (m_iConverterHandle) {
+    close(m_iConverterHandle->device);
+    delete m_iConverterHandle;
+    m_iConverterHandle = NULL;
+  }
+
+  if (m_iDecoderHandle) {
+    close(m_iDecoderHandle->device);
+    delete m_iDecoderHandle;
+    m_iDecoderHandle = NULL;
+  }
+
+}
+
+bool CDVDVideoCodecMFC::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) {
+  struct v4l2_format fmt;
+  struct v4l2_crop crop;
+  struct V4l2SinkBuffer sinkBuffer;
+  V4l2Device *finalSink = NULL;
+  int finalFormat = -1;
+  unsigned int resultVideoWidth;
+  unsigned int resultVideoHeight;
+  int resultLineSize;
+  unsigned int extraSize = 0;
+  uint8_t *extraData = NULL;
+
+  m_hints = hints;
+  if (m_hints.software)
+    return false;
+
+  Dispose();
+
+  m_Buffer = new V4l2SinkBuffer();
+  m_BufferNowOnScreen = new V4l2SinkBuffer();
+  m_BufferNowOnScreen->iIndex = -1;
+  m_bVideoConvert = false;
+  m_bDropPictures = false;
+  m_droppedFrames = 0;
+  m_codecPts = DVD_NOPTS_VALUE;
+  memzero(m_videoBuffer);
+
+  if (!OpenDevices()) {
+    CLog::Log(LOGERROR, "%s::%s - No Exynos MFC Decoder/Converter found", CLASSNAME, __func__);
+    return false;
+  }
+
+  m_bVideoConvert = m_converter.Open(m_hints.codec, (uint8_t *)m_hints.extradata, m_hints.extrasize, true);
+
+  if(m_bVideoConvert) {
+    if(m_converter.GetExtraData() != NULL && m_converter.GetExtraSize() > 0) {
+      extraSize = m_converter.GetExtraSize();
+      extraData = m_converter.GetExtraData();
+    }
+  } else {
+    if(m_hints.extrasize > 0 && m_hints.extradata != NULL) {
+      extraSize = m_hints.extrasize;
+      extraData = (uint8_t*)m_hints.extradata;
+    }
+  }
+
+  // Test what formats we can get finally
+  // If converter is present, it is our final sink
+  finalSink = m_iConverterHandle ? m_iConverterHandle : m_iDecoderHandle;
+  // Test NV12 2 Planes Y/CbCr
+  memzero(fmt);
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_NV12M;
+  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
+    finalFormat = V4L2_PIX_FMT_NV12M;
+/*
+  memzero(fmt);
+  // Test YUV420 3 Planes Y/Cb/Cr
+  fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+  fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420M;
+  if (ioctl(finalSink->device, VIDIOC_TRY_FMT, &fmt) == 0)
+    finalFormat = V4L2_PIX_FMT_YUV420M;
+*/
+
+  // No suitable output formats available
+  if (finalFormat < 0) {
+    CLog::Log(LOGERROR, "%s::%s - No suitable format on %s to convert to found", CLASSNAME, __func__, finalSink->name);
+    return false;
+  }
+
+  // Create MFC Output sink (the one where encoded frames are feed)
+  m_MFCOutput = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+  memzero(fmt);
+  switch(m_hints.codec)
+  {
+    case AV_CODEC_ID_VC1:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_VC1_ANNEX_G;
+      m_name = "mfc-vc1";
+      break;
+    case AV_CODEC_ID_MPEG1VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG1;
+      m_name = "mfc-mpeg1";
+      break;
+    case AV_CODEC_ID_MPEG2VIDEO:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG2;
+      m_name = "mfc-mpeg2";
+      break;
+    case AV_CODEC_ID_MPEG4:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_MPEG4;
+      m_name = "mfc-mpeg4";
+      break;
+    case AV_CODEC_ID_H263:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H263;
+      m_name = "mfc-h263";
+      break;
+    case AV_CODEC_ID_H264:
+      fmt.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_H264;
+      m_name = "mfc-h264";
+      break;
+    default:
+      return false;
+  }
+  fmt.fmt.pix_mp.plane_fmt[0].sizeimage = BUFFER_SIZE;
+  // Set encoded format
+  if (!m_MFCOutput->SetFormat(&fmt))
+    return false;
+  // Init with number of input buffers predefined
+  if (!m_MFCOutput->Init(INPUT_BUFFERS))
+    return false;
+
+  // Get empty buffer to fill
+  if (!m_MFCOutput->GetBuffer(&sinkBuffer))
+    return false;
+  // Fill it with the header
+  sinkBuffer.iBytesUsed[0] = extraSize;
+  memcpy(sinkBuffer.cPlane[0], extraData, extraSize);
+  // Enqueue buffer
+  if (!m_MFCOutput->PushBuffer(&sinkBuffer))
+    return false;
+
+  // Create MFC Capture sink (the one from which decoded frames are read)
+  m_MFCCapture = new CLinuxV4l2Sink(m_iDecoderHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+  memzero(fmt);
+  // If there is no converter set output format on the MFC Capture sink
+  if (!m_iConverterHandle) {
+    fmt.fmt.pix_mp.pixelformat = finalFormat;
+    if (!m_MFCCapture->SetFormat(&fmt))
+        return false;
+  }
+
+  // Turn on MFC Output with header in it to initialize MFC with all we just setup
+  m_MFCOutput->StreamOn(VIDIOC_STREAMON);
+
+  // Initialize MFC Capture
+  if (!m_MFCCapture->Init(0))
+    return false;
+  // Queue all buffers (empty) to MFC Capture
+  m_MFCCapture->QueueAll();
+
+  // Read the format of MFC Capture
+  if (!m_MFCCapture->GetFormat(&fmt))
+    return false;
+  // Size of resulting picture coming out of MFC
+  // It will be aligned by 16 since the picture is tiled
+  // We need this to know where to split buffer line by line
+  resultLineSize = fmt.fmt.pix_mp.width;
+  // Get MFC capture crop settings
+  if (!m_MFCCapture->GetCrop(&crop))
+    return false;
+  // This is the picture boundaries we are interested in, everything outside is alignement because of tiled MFC output
+  resultVideoWidth = crop.c.width;
+  resultVideoHeight = crop.c.height;
+
+  // Turn on MFC Capture
+  m_MFCCapture->StreamOn(VIDIOC_STREAMON);
+
+  // If converter is needed (we need to untile the picture from format MFC produces it)
+  if (m_iConverterHandle) {
+    // Create FIMC Output sink
+    m_FIMCOutput = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+    // Set the FIMC Output format to the one read from MFC
+    if (!m_FIMCOutput->SetFormat(&fmt))
+      return false;
+    // Set the FIMC Output crop to the one read from MFC
+    if (!m_FIMCOutput->SetCrop(&crop))
+      return false;
+    // Init FIMC Output and link it to buffers of MFC Capture
+    if (!m_FIMCOutput->Init(m_MFCCapture))
+      return false;
+    // Get FIMC Output crop settings
+    if (!m_FIMCOutput->GetCrop(&crop))
+      return false;
+
+    // Create FIMC Capture sink
+    m_FIMCCapture = new CLinuxV4l2Sink(m_iConverterHandle, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
+    // Set the final picture format and the same picture dimension settings to FIMC Capture
+    // as picture crop coming from MFC (original picture dimensions)
+    memzero(fmt);
+    fmt.fmt.pix_mp.pixelformat = finalFormat;
+    fmt.fmt.pix_mp.width = crop.c.width;
+    fmt.fmt.pix_mp.height = crop.c.height;
+    fmt.fmt.pix_mp.field = V4L2_FIELD_ANY;
+    if (!m_FIMCCapture->SetFormat(&fmt))
+      return false;
+    // Init FIMC capture with number of buffers predefined
+    if (!m_FIMCCapture->Init(OUTPUT_BUFFERS))
+      return false;
+
+    // Queue all buffers (empty) to FIMC Capture
+    m_FIMCCapture->QueueAll();
+
+    // Read FIMC capture format settings
+    if (!m_FIMCCapture->GetFormat(&fmt))
+      return false;
+    resultLineSize = fmt.fmt.pix_mp.width;
+    // Read FIMC capture crop settings
+    if (!m_FIMCCapture->GetCrop(&crop))
+      return false;
+    resultVideoWidth = crop.c.width;
+    resultVideoHeight = crop.c.height;
+
+    // Turn on FIMC Output and Capture enabling the converter
+    m_FIMCOutput->StreamOn(VIDIOC_STREAMON);
+    m_FIMCCapture->StreamOn(VIDIOC_STREAMON);
+  }
+
+  m_videoBuffer.iFlags          = DVP_FLAG_ALLOCATED;
+
+  m_videoBuffer.color_range     = 0;
+  m_videoBuffer.color_matrix    = 4;
+
+  m_videoBuffer.iDisplayWidth   = resultVideoWidth;
+  m_videoBuffer.iDisplayHeight  = resultVideoHeight;
+  m_videoBuffer.iWidth          = resultVideoWidth;
+  m_videoBuffer.iHeight         = resultVideoHeight;
+
+  m_videoBuffer.data[0]         = NULL;
+  m_videoBuffer.data[1]         = NULL;
+  m_videoBuffer.data[2]         = NULL;
+  m_videoBuffer.data[3]         = NULL;
+
+  m_videoBuffer.pts             = DVD_NOPTS_VALUE;
+  m_videoBuffer.dts             = DVD_NOPTS_VALUE;
+
+  m_videoBuffer.iLineSize[0]    = resultLineSize;
+  m_videoBuffer.iLineSize[3]    = 0;
+
+  if (finalFormat == V4L2_PIX_FMT_NV12M) {
+    m_videoBuffer.format          = RENDER_FMT_NV12;
+    m_videoBuffer.iLineSize[1]    = resultLineSize;
+    m_videoBuffer.iLineSize[2]    = 0;
+  } else if (finalFormat == V4L2_PIX_FMT_YUV420M) {
+    /*
+     Due to BUG in MFC v8 (-XU3) firmware the Y plane of the picture has the right line size,
+     but the U and V planes line sizes are actually halves of Y plane line size padded to 32
+     This is pure workaround for -XU3 MFCv8 firmware "MFC v8.0, F/W: 14yy, 01mm, 13dd (D)
+     Seems that only MPEG2 is affected
+    */
+    // Only on -XU3 there are no converter, but the output format can be YUV420
+    // So this is the easiest way to distinguish -XU3 from -U3 with FIMC
+    if (!m_iConverterHandle && m_hints.codec == AV_CODEC_ID_MPEG2VIDEO)
+      resultLineSize = resultLineSize + (32 - resultLineSize%32);
+
+    m_videoBuffer.format          = RENDER_FMT_YUV420P;
+    m_videoBuffer.iLineSize[1]    = resultLineSize >> 1;
+    m_videoBuffer.iLineSize[2]    = resultLineSize >> 1;
+  }
+
+  m_BufferNowOnScreen->iIndex = -1;
+  m_bCodecHealthy = true;
+
+  m_processInfo.SetVideoDecoderName(m_name, true);
+  m_processInfo.SetVideoDimensions(resultVideoWidth, resultVideoHeight);
+  m_processInfo.SetVideoDeintMethod("hardware");
+  m_processInfo.SetVideoPixelFormat("YUV 4:2:0");
+
+  CLog::Log(LOGNOTICE, "%s::%s - MFC Setup succesfull (%dx%d, linesize %d, format 0x%x), start streaming", CLASSNAME, __func__, resultVideoWidth, resultVideoHeight, resultLineSize, finalFormat);
+
+  return true;
+
+}
+
+void CDVDVideoCodecMFC::SetDropState(bool bDrop) {
+
+  debug_log(LOGDEBUG, "%s::%s - setting state to %d", CLASSNAME, __func__, bDrop);
+  m_bDropPictures = bDrop;
+  if (m_bDropPictures)
+    m_videoBuffer.iFlags |= DVP_FLAG_DROPPED;
+  else
+    m_videoBuffer.iFlags &= ~DVP_FLAG_DROPPED;
+
+}
+
+int CDVDVideoCodecMFC::Decode(BYTE* pData, int iSize, double dts, double pts) {
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  //unsigned int dtime = XbmcThreads::SystemClockMillis();
+  debug_log(LOGDEBUG, "%s::%s - input frame iSize %d, pts %lf, dts %lf", CLASSNAME, __func__, iSize, pts, dts);
+
+  if(pData) {
+    int demuxer_bytes = iSize;
+    BYTE *demuxer_content = pData;
+
+    if(m_bVideoConvert) {
+      m_converter.Convert(demuxer_content, demuxer_bytes);
+      demuxer_bytes = m_converter.GetConvertSize();
+      demuxer_content = m_converter.GetConvertBuffer();
+    }
+
+    m_MFCOutput->Poll(1000/3); // Wait up to 0.3 of a second for buffer availability
+    if (m_MFCOutput->GetBuffer(m_Buffer)) {
+      debug_log(LOGDEBUG, "%s::%s - Got empty buffer %d from MFC Output, filling", CLASSNAME, __func__, m_Buffer->iIndex);
+      m_Buffer->iBytesUsed[0] = demuxer_bytes;
+      memcpy((uint8_t *)m_Buffer->cPlane[0], demuxer_content, m_Buffer->iBytesUsed[0]);
+      long* longPts = (long*)&pts;
+      m_Buffer->timeStamp.tv_sec = longPts[0];
+      m_Buffer->timeStamp.tv_usec = longPts[1];
+
+      if (!m_MFCOutput->PushBuffer(m_Buffer)) {
+        m_bCodecHealthy = false;
+        return VC_FLUSHED; // MFC unrecoverable error, reset needed
+      }
+    } else {
+      if (errno == EAGAIN)
+        CLog::Log(LOGERROR, "%s::%s - MFC OUTPUT All buffers are queued and busy, no space for new frame to decode. Very broken situation. Current encoded frame will be lost", CLASSNAME, __func__);
+      else {
+        m_bCodecHealthy = false;
+        return VC_FLUSHED; // MFC unrecoverable error, reset needed
+      }
+    }
+  }
+
+  // Get a buffer from MFC Capture
+  if (!m_MFCCapture->DequeueBuffer(m_Buffer)) {
+    if (errno == EAGAIN)
+      return VC_BUFFER;
+    else
+      return VC_ERROR;
+  }
+
+  if (m_iConverterHandle) {
+
+    if (m_bDropPictures) {
+      CLog::Log(LOGWARNING, "%s::%s - Dropping frame with index %d", CLASSNAME, __func__, m_Buffer->iIndex);
+      long longPts[2] = { m_Buffer->timeStamp.tv_sec, m_Buffer->timeStamp.tv_usec };
+      m_codecPts = *((double*)&longPts[0]);
+      m_droppedFrames++;
+      // Queue it back to MFC CAPTURE since we are in an underrun condition
+      m_MFCCapture->PushBuffer(m_Buffer);
+      return (VC_DROPPED | VC_BUFFER);
+    }
+
+    // Push the buffer got from MFC Capture to FIMC Output (decoded from decoder to converter)
+    if (!m_FIMCOutput->PushBuffer(m_Buffer)) {
+      m_bCodecHealthy = false;
+      return VC_FLUSHED; // FIMC unrecoverable error, reset needed
+    }
+    // Get a buffer from FIMC Capture
+    if (!m_FIMCCapture->DequeueBuffer(m_Buffer)) {
+      if (errno == EAGAIN)
+        return VC_BUFFER;
+      else
+        return VC_ERROR;
+    }
+  }
+
+  // We got a new buffer to show, so we can enqeue back the buffer wich was on screen
+  if (m_BufferNowOnScreen->iIndex > -1) {
+    if (m_iConverterHandle)
+      m_FIMCCapture->PushBuffer(m_BufferNowOnScreen);
+    else
+      m_MFCCapture->PushBuffer(m_BufferNowOnScreen);
+    m_BufferNowOnScreen->iIndex = -1;
+  }
+
+  long longPts[2] = { m_Buffer->timeStamp.tv_sec, m_Buffer->timeStamp.tv_usec };
+  m_videoBuffer.data[0]         = (BYTE*)m_Buffer->cPlane[0];
+  m_videoBuffer.data[1]         = (BYTE*)m_Buffer->cPlane[1];
+  m_videoBuffer.data[2]         = (BYTE*)m_Buffer->cPlane[2];
+  m_videoBuffer.pts             = m_codecPts = *((double*)&longPts[0]);
+
+  std::swap(m_Buffer, m_BufferNowOnScreen);
+
+  if (m_iConverterHandle && m_FIMCOutput->DequeueBuffer(m_Buffer))
+    m_MFCCapture->PushBuffer(m_Buffer);
+
+  //debug_log("Decode time: %d", XbmcThreads::SystemClockMillis() - dtime);
+  // Picture is finally ready to be processed further and more info can be enqueued
+  return (VC_PICTURE | VC_BUFFER);
+
+}
+
+bool CDVDVideoCodecMFC::GetCodecStats(double &pts, int &droppedFrames, int &skippedPics) {
+  pts = m_codecPts;
+  droppedFrames = m_droppedFrames;
+  skippedPics = 0;
+  m_droppedFrames = 0;
+
+  return true;
+}
+
+void CDVDVideoCodecMFC::Reset() {
+
+  m_droppedFrames = 0;
+  m_codecPts = DVD_NOPTS_VALUE;
+
+  if (m_bCodecHealthy) {
+    CLog::Log(LOGDEBUG, "%s::%s - Codec Reset requested, but codec is healthy, doing soft-flush", CLASSNAME, __func__);
+    m_MFCOutput->SoftRestart();
+    m_MFCCapture->SoftRestart();
+    if (!m_iConverterHandle)
+      m_BufferNowOnScreen->iIndex = -1;
+  } else {
+    CLog::Log(LOGERROR, "%s::%s - Codec Reset. Reinitializing", CLASSNAME, __func__);
+    CDVDCodecOptions options;
+    // We need full MFC/FIMC reset with device reopening.
+    // I wasn't able to reinitialize both IP's without fully closing and reopening them.
+    // There are always some clips that cause MFC or FIMC go into state which cannot be reset without close/open
+    Open(m_hints, options);
+  }
+
+}
+
+bool CDVDVideoCodecMFC::GetPicture(DVDVideoPicture* pDvdVideoPicture) {
+
+  *pDvdVideoPicture = m_videoBuffer;
+  debug_log(LOGDEBUG, "%s::%s - output frame pts %lf", CLASSNAME, __func__, m_videoBuffer.pts);
+  return true;
+
+}
diff -Nur a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecMFC.h	2017-09-29 14:36:36.183110219 -0400
@@ -0,0 +1,67 @@
+#pragma once
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDStreamInfo.h"
+  #include "utils/BitstreamConverter.h"
+  #include "xbmc/linux/LinuxV4l2Sink.h"
+#else
+  #include "xbmcstubs.h"
+  #include "LinuxV4l2Sink.h"
+#endif
+
+#ifndef V4L2_CAP_VIDEO_M2M_MPLANE
+  #define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
+#endif
+
+#define BUFFER_SIZE        1048576 // Compressed frame size. 1080p mpeg4 10Mb/s can be >256k in size, so this is to make sure frame fits into the buffer
+                                   // For very unknown reason lesser than 1Mb buffer causes MFC to corrupt its own setup, setting inapropriate values
+#define INPUT_BUFFERS      3       // 3 input buffers. 2 is enough almost for everything, but on some heavy videos 3 makes a difference
+#define OUTPUT_BUFFERS     3       // Triple buffering for smooth output
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+class CDVDVideoCodecMFC : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecMFC(CProcessInfo &processInfo);
+  virtual ~CDVDVideoCodecMFC();
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose();
+  virtual int Decode(BYTE* pData, int iSize, double dts, double pts);
+  virtual void Reset();
+  bool GetPictureCommon(DVDVideoPicture* pDvdVideoPicture);
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
+  virtual bool GetCodecStats(double &pts, int &droppedFrames, int &skippedPics) override;
+
+protected:
+  std::string m_name;
+
+  bool m_bCodecHealthy;
+
+  V4l2Device *m_iDecoderHandle;
+  V4l2Device *m_iConverterHandle;
+
+  CLinuxV4l2Sink *m_MFCCapture;
+  CLinuxV4l2Sink *m_MFCOutput;
+  CLinuxV4l2Sink *m_FIMCCapture;
+  CLinuxV4l2Sink *m_FIMCOutput;
+
+  V4l2SinkBuffer *m_Buffer;
+  V4l2SinkBuffer *m_BufferNowOnScreen;
+
+  bool m_bVideoConvert;
+  CDVDStreamInfo m_hints;
+
+  CBitstreamConverter m_converter;
+  bool m_bDropPictures;
+
+  DVDVideoPicture   m_videoBuffer;
+
+  int m_droppedFrames;
+  double m_codecPts;
+
+  bool OpenDevices();
+};
diff -Nur a/xbmc/linux/CMakeLists.txt b/xbmc/linux/CMakeLists.txt
--- a/xbmc/linux/CMakeLists.txt	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/linux/CMakeLists.txt	2017-09-29 14:24:03.072493467 -0400
@@ -5,6 +5,7 @@
             FDEventMonitor.cpp
             LinuxResourceCounter.cpp
             LinuxTimezone.cpp
+            LinuxV4l2Sink.cpp
             PosixMountProvider.cpp
             RBP.cpp
             XFileUtils.cpp
@@ -20,6 +21,7 @@
             FDEventMonitor.h
             LinuxResourceCounter.h
             LinuxTimezone.h
+            LinuxV4l2Sink.h
             PlatformDefs.h
             PlatformInclude.h
             PosixMountProvider.h
diff -Nur a/xbmc/linux/LinuxV4l2Sink.cpp b/xbmc/linux/LinuxV4l2Sink.cpp
--- a/xbmc/linux/LinuxV4l2Sink.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/linux/LinuxV4l2Sink.cpp	2017-09-29 14:37:22.839184081 -0400
@@ -0,0 +1,311 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+
+  #include "utils/log.h"
+#endif
+
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <linux/media.h>
+
+#include "LinuxV4l2Sink.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxV4l2Sink"
+
+CLinuxV4l2Sink::CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type) {
+  CLog::Log(LOGDEBUG, "%s::%s - Creating Sink, Device %s, Type %d", CLASSNAME, __func__, device->name, type);
+  m_Device = device;
+  m_Type = type;
+  m_NumBuffers = 0;
+  m_NumPlanes = 0;
+  m_Addresses = NULL;
+  m_Buffers = NULL;
+  m_Planes = NULL;
+}
+
+CLinuxV4l2Sink::~CLinuxV4l2Sink() {
+  CLog::Log(LOGDEBUG, "%s::%s - Destroying Sink, Device %s, Type %d", CLASSNAME, __func__, m_Device->name, m_Type);
+
+  StreamOn(VIDIOC_STREAMOFF);
+
+  if (m_Memory == V4L2_MEMORY_MMAP)
+    for (int i = 0; i < m_NumBuffers*m_NumPlanes; i++)
+      if(m_Addresses[i] != (unsigned long)MAP_FAILED)
+        if (munmap((void *)m_Addresses[i], m_Planes[i].length) == 0)
+          CLog::Log(LOGDEBUG, "%s::%s - Device %s, Munmapped Plane %d size %u at 0x%lx", CLASSNAME, __func__, m_Device->name, i, m_Planes[i].length, m_Addresses[i]);
+  if (m_Planes)
+    delete[] m_Planes;
+  if (m_Buffers)
+    delete[] m_Buffers;
+  if (m_Addresses)
+    delete[] m_Addresses;
+}
+
+// Init for MMAP buffers
+bool CLinuxV4l2Sink::Init(int buffersCount = 0) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init MMAP %d buffers", CLASSNAME, __func__, m_Device->name, m_Type, buffersCount);
+  m_Memory = V4L2_MEMORY_MMAP;
+
+  struct v4l2_format format;
+  if (!GetFormat(&format))
+    return false;
+
+  if (buffersCount == 0 && m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+    struct v4l2_control ctrl;
+    ctrl.id = V4L2_CID_MIN_BUFFERS_FOR_CAPTURE;
+    if (ioctl(m_Device->device, VIDIOC_G_CTRL, &ctrl)) {
+      CLog::Log(LOGERROR, "%s::%s - Device %s, Type %d, Error getting number of buffers for capture (V4L2_CID_MIN_BUFFERS_FOR_CAPTURE VIDIOC_G_CTRL)", CLASSNAME, __func__, m_Device->name, m_Type);
+      return false;
+    }
+    buffersCount = (int)(ctrl.value * 1.5); //Most of the time we need 50% more extra capture buffers than device reported would be enough
+  }
+
+  m_NumBuffers = RequestBuffers(buffersCount);
+  if (m_NumBuffers < 1)
+    return false;
+  m_Buffers = new v4l2_buffer[m_NumBuffers];
+  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
+  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
+  if (!QueryBuffers())
+    return false;
+  if (!MmapBuffers())
+    return false;
+  return true;
+}
+// Init for USERPTR buffers
+bool CLinuxV4l2Sink::Init(CLinuxV4l2Sink *sink) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Init UserPTR", CLASSNAME, __func__, m_Device->name, m_Type);
+  m_Memory = V4L2_MEMORY_USERPTR;
+
+  struct v4l2_format format;
+  if (!GetFormat(&format))
+    return false;
+
+  m_NumBuffers = sink->m_NumBuffers;
+  m_NumBuffers = RequestBuffers(m_NumBuffers);
+  if (m_NumBuffers < 1)
+    return false;
+  m_Buffers = new v4l2_buffer[m_NumBuffers];
+  m_Planes = new v4l2_plane[m_NumPlanes * m_NumBuffers];
+  m_Addresses = new unsigned long[m_NumPlanes * m_NumBuffers];
+  if (!QueryBuffers())
+    return false;
+  for (int i = 0; i < m_NumPlanes * m_NumBuffers; i++) {
+    m_Addresses[i] = sink->m_Addresses[i];
+    m_Planes[i].m.userptr = m_Addresses[i];
+  }
+  return true;
+}
+
+void CLinuxV4l2Sink::SoftRestart() {
+  StreamOn(VIDIOC_STREAMOFF);
+
+  while (!iFreeBuffers.empty())
+    iFreeBuffers.pop();
+  for (int i = 0; i < m_NumBuffers; i++)
+    iFreeBuffers.push(m_Buffers[i].index);
+
+  if (m_Type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+    QueueAll();
+
+  StreamOn(VIDIOC_STREAMON);
+}
+
+bool CLinuxV4l2Sink::GetFormat(v4l2_format *format) {
+  memset(format, 0, sizeof(struct v4l2_format));
+  format->type = m_Type;
+  if (ioctl(m_Device->device, VIDIOC_G_FMT, format)) {
+    CLog::Log(LOGERROR, "%s::%s - Error getting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  m_NumPlanes = format->fmt.pix_mp.num_planes;
+  CLog::Log(LOGDEBUG, "%s::%s - G_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
+  return true;
+}
+
+bool CLinuxV4l2Sink::SetFormat(v4l2_format *format) {
+  format->type = m_Type;
+  CLog::Log(LOGDEBUG, "%s::%s - S_FMT Device %s, Type %d format 0x%x (%dx%d), planes=%d, plane[0]=%d plane[1]=%d, plane[2]=%d", CLASSNAME, __func__, m_Device->name, format->type, format->fmt.pix_mp.pixelformat, format->fmt.pix_mp.width, format->fmt.pix_mp.height, format->fmt.pix_mp.num_planes, format->fmt.pix_mp.plane_fmt[0].sizeimage, format->fmt.pix_mp.plane_fmt[1].sizeimage, format->fmt.pix_mp.plane_fmt[2].sizeimage);
+  if (ioctl(m_Device->device, VIDIOC_S_FMT, format)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting sink format. Device %s, Type %d. (VIDIOC_G_FMT)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::GetCrop(v4l2_crop *crop) {
+  memset(crop, 0, sizeof(struct v4l2_crop));
+  crop->type = m_Type;
+  if (ioctl(m_Device->device, VIDIOC_G_CROP, crop)) {
+    CLog::Log(LOGERROR, "%s::%s - Error getting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - G_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
+  return true;
+}
+
+bool CLinuxV4l2Sink::SetCrop(v4l2_crop *crop) {
+  crop->type = m_Type;
+  CLog::Log(LOGDEBUG, "%s::%s - S_CROP Device %s, Type %d, crop (%dx%d)", CLASSNAME, __func__, m_Device->name, crop->type, crop->c.width, crop->c.height);
+  if (ioctl(m_Device->device, VIDIOC_S_CROP, crop)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting sink crop. Device %s, Type %d. (VIDIOC_G_CROP)", CLASSNAME, __func__, m_Device->name, m_Type);
+    return false;
+  }
+  return true;
+}
+
+int CLinuxV4l2Sink::RequestBuffers(int buffersCount) {
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, RequestBuffers %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, buffersCount);
+  struct v4l2_requestbuffers reqbuf;
+  memset(&reqbuf, 0, sizeof(struct v4l2_requestbuffers));
+  reqbuf.type     = m_Type;
+  reqbuf.memory   = m_Memory;
+  reqbuf.count    = buffersCount;
+
+  if (ioctl(m_Device->device, VIDIOC_REQBUFS, &reqbuf)) {
+    CLog::Log(LOGERROR, "%s::%s - Error requesting buffers. Device %s, Type %d, Memory %d. (VIDIOC_REQBUFS)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
+    return V4L2_ERROR;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d, Buffers allowed %d", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory, reqbuf.count);
+  return reqbuf.count;
+}
+
+bool CLinuxV4l2Sink::QueryBuffers() {
+  memset(m_Buffers, 0, m_NumBuffers * sizeof(struct v4l2_buffer));
+  memset(m_Planes, 0, m_NumBuffers * m_NumPlanes * sizeof(struct v4l2_plane));
+
+  for(int i = 0; i < m_NumBuffers; i++) {
+    m_Buffers[i].type      = m_Type;
+    m_Buffers[i].memory    = m_Memory;
+    m_Buffers[i].index     = i;
+    m_Buffers[i].m.planes  = &m_Planes[i*m_NumPlanes];
+    m_Buffers[i].length    = m_NumPlanes;
+
+    if (ioctl(m_Device->device, VIDIOC_QUERYBUF, &m_Buffers[i])) {
+      CLog::Log(LOGERROR, "%s::%s - Error querying buffers. Device %s, Type %d, Memory %d. (VIDIOC_QUERYBUF)", CLASSNAME, __func__, m_Device->name, m_Type, m_Memory);
+      return false;
+    }
+
+    iFreeBuffers.push(m_Buffers[i].index);
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::MmapBuffers() {
+  for(int i = 0; i < m_NumBuffers * m_NumPlanes; i++) {
+    if(m_Planes[i].length) {
+      m_Addresses[i] = (unsigned long)mmap(NULL, m_Planes[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, m_Device->device, m_Planes[i].m.mem_offset);
+      if (m_Addresses[i] == (unsigned long)MAP_FAILED)
+        return false;
+      CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, MMapped Plane %d at 0x%x to address 0x%lx", CLASSNAME, __func__, m_Device->name, m_Type, i, m_Planes[i].m.mem_offset, m_Addresses[i]);
+    }
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::StreamOn(int state) {
+  if(ioctl(m_Device->device, state, &m_Type)) {
+    CLog::Log(LOGERROR, "%s::%s - Error setting device state to %d, Device %s, Type %d.", CLASSNAME, __func__, state, m_Device->name, m_Type);
+    return false;
+  }
+  CLog::Log(LOGDEBUG, "%s::%s - Device %s, Type %d, %d", CLASSNAME, __func__, m_Device->name, m_Type, state);
+  return true;
+}
+
+bool CLinuxV4l2Sink::QueueBuffer(v4l2_buffer *buffer) {
+  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d <- %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
+  if (ioctl(m_Device->device, VIDIOC_QBUF, buffer)) {
+    CLog::Log(LOGERROR, "%s::%s - Error queueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
+    return false;
+  }
+  return true;
+}
+bool CLinuxV4l2Sink::DequeueBuffer(v4l2_buffer *buffer) {
+  if (ioctl(m_Device->device, VIDIOC_DQBUF, buffer)) {
+    if (errno != EAGAIN) CLog::Log(LOGERROR, "%s::%s - Error dequeueing buffer. Device %s, Type %d, Memory %d. Buffer %d, errno %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index, errno);
+    return false;
+  }
+  debug_log(LOGDEBUG, "%s::%s - Device %s, Type %d, Memory %d -> %d", CLASSNAME, __func__, m_Device->name, buffer->type, buffer->memory, buffer->index);
+  return true;
+}
+
+bool CLinuxV4l2Sink::DequeueBuffer(V4l2SinkBuffer *buffer) {
+  struct v4l2_buffer buf;
+  struct v4l2_plane  planes[m_NumPlanes];
+  memset(&planes, 0, sizeof(struct v4l2_plane) * m_NumPlanes);
+  memset(&buf, 0, sizeof(struct v4l2_buffer));
+  buf.type     = m_Type;
+  buf.memory   = m_Memory;
+  buf.m.planes = planes;
+  buf.length   = m_NumPlanes;
+  if (!DequeueBuffer(&buf))
+    return false;
+
+  buffer->iIndex = buf.index;
+  buffer->timeStamp = buf.timestamp;
+  for (int i = 0; i < m_NumPlanes; i++)
+    buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
+  return true;
+}
+
+bool CLinuxV4l2Sink::GetBuffer(V4l2SinkBuffer *buffer) {
+  if (iFreeBuffers.empty()) {
+    if (!DequeueBuffer(buffer))
+      return false;
+  } else {
+    buffer->iIndex = iFreeBuffers.front();
+    buffer->timeStamp = m_Buffers[buffer->iIndex].timestamp;
+    iFreeBuffers.pop();
+    for (int i = 0; i < m_NumPlanes; i++)
+      buffer->cPlane[i] = (void *)m_Addresses[buffer->iIndex * m_NumPlanes + i];
+  }
+  return true;
+}
+
+bool CLinuxV4l2Sink::PushBuffer(V4l2SinkBuffer *buffer) {
+  if (m_Memory == V4L2_MEMORY_USERPTR)
+    for (int i = 0; i < m_NumPlanes; i++)
+      m_Buffers[buffer->iIndex].m.planes[i].m.userptr = (long unsigned int)buffer->cPlane[i];
+
+  if (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+    m_Buffers[buffer->iIndex].timestamp = buffer->timeStamp;
+    m_Buffers[buffer->iIndex].flags |= V4L2_BUF_FLAG_TIMESTAMP_COPY;
+    for (int i = 0; i < m_NumPlanes; i++)
+      m_Buffers[buffer->iIndex].m.planes[i].bytesused = buffer->iBytesUsed[i];
+  }
+
+  if (!QueueBuffer(&m_Buffers[buffer->iIndex]))
+    return false;
+  return true;
+}
+
+int CLinuxV4l2Sink::Poll(int timeout) {
+  struct pollfd p;
+  p.fd = m_Device->device;
+  p.events = POLLERR;
+  (m_Type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) ? p.events |= POLLOUT : p.events |= POLLIN;
+
+  return poll(&p, 1, timeout);
+}
+
+bool CLinuxV4l2Sink::QueueAll() {
+  while (!iFreeBuffers.empty()) {
+    if (!QueueBuffer(&m_Buffers[iFreeBuffers.front()]))
+      return false;
+    iFreeBuffers.pop();
+  }
+  return true;
+}
diff -Nur a/xbmc/linux/LinuxV4l2Sink.h b/xbmc/linux/LinuxV4l2Sink.h
--- a/xbmc/linux/LinuxV4l2Sink.h	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/linux/LinuxV4l2Sink.h	2017-09-29 14:37:20.207180065 -0400
@@ -0,0 +1,71 @@
+#pragma once
+
+#include <queue>
+#include <string>
+#include <poll.h>
+#include <linux/videodev2.h>
+
+#ifndef V4L2_BUF_FLAG_TIMESTAMP_COPY
+  #define V4L2_BUF_FLAG_TIMESTAMP_COPY 0x4000
+#endif
+
+#define V4L2_ERROR -1
+#define V4L2_BUSY  1
+#define V4L2_READY 2
+#define V4L2_OK    3
+
+#ifdef _DEBUG
+  #define debug_log(...) CLog::Log(__VA_ARGS__)
+#else
+  #define debug_log(...)
+#endif
+
+typedef struct V4l2Device
+{
+  int     device;
+  char    name[32];
+} V4l2Device;
+
+typedef struct V4l2SinkBuffer
+{
+  int     iIndex;
+  int     iBytesUsed[4];
+  void    *cPlane[4];
+  struct  timeval timeStamp;
+} V4l2SinkBuffer;
+
+class CLinuxV4l2Sink
+{
+public:
+  CLinuxV4l2Sink(V4l2Device *device, enum v4l2_buf_type type);
+  ~CLinuxV4l2Sink();
+
+  bool Init(int buffersCount);
+  bool Init(CLinuxV4l2Sink *sink);
+  void SoftRestart();
+  bool GetFormat(v4l2_format *format);
+  bool SetFormat(v4l2_format *format);
+  bool GetCrop(v4l2_crop *crop);
+  bool SetCrop(v4l2_crop *crop);
+  bool GetBuffer(V4l2SinkBuffer* buffer);
+  bool DequeueBuffer(V4l2SinkBuffer* buffer);
+  bool PushBuffer(V4l2SinkBuffer* buffer);
+  bool StreamOn(int state);
+  bool QueueAll();
+  int Poll(int timeout);
+private:
+  V4l2Device *m_Device;
+  int m_NumPlanes;
+  int m_NumBuffers;
+  std::queue<int> iFreeBuffers;
+  enum v4l2_memory m_Memory;
+  enum v4l2_buf_type m_Type;
+  v4l2_buffer *m_Buffers;
+  v4l2_plane *m_Planes;
+  unsigned long *m_Addresses;
+  int RequestBuffers(int buffersCount);
+  bool QueryBuffers();
+  bool MmapBuffers();
+  bool QueueBuffer(v4l2_buffer *buffer);
+  bool DequeueBuffer(v4l2_buffer *buffer);
+};
diff -Nur a/xbmc/system_gl.h b/xbmc/system_gl.h
--- a/xbmc/system_gl.h	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/system_gl.h	2017-09-29 14:25:31.449017630 -0400
@@ -42,6 +42,10 @@
     #include <OpenGL/glext.h>
   #endif
 #elif HAS_GLES == 2
+  // always define GL_GLEXT_PROTOTYPES before include gl headers
+  #if !defined(GL_GLEXT_PROTOTYPES)
+    #define GL_GLEXT_PROTOTYPES
+  #endif
   #if defined(TARGET_DARWIN)
     #include <OpenGLES/ES2/gl.h>
     #include <OpenGLES/ES2/glext.h>
diff -Nur a/xbmc/windowing/X11/GLContextEGL.cpp b/xbmc/windowing/X11/GLContextEGL.cpp
--- a/xbmc/windowing/X11/GLContextEGL.cpp	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/windowing/X11/GLContextEGL.cpp	2017-09-29 15:39:51.356172894 -0400
@@ -30,6 +30,10 @@
   #include <GL/glu.h>
   #include <GL/glext.h>
 #elif HAS_GLES == 2
+  // always define GL_GLEXT_PROTOTYPES before include gl headers
+  #if !defined(GL_GLEXT_PROTOTYPES)
+    #define GL_GLEXT_PROTOTYPES
+  #endif
   #include <GLES2/gl2.h>
   #include <GLES2/gl2ext.h>
 #endif
diff -Nur a/xbmc/windowing/egl/CMakeLists.txt b/xbmc/windowing/egl/CMakeLists.txt
--- a/xbmc/windowing/egl/CMakeLists.txt	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/windowing/egl/CMakeLists.txt	2017-09-29 14:27:05.301486879 -0400
@@ -1,9 +1,10 @@
 if(OPENGLES_FOUND OR AML_FOUND OR IMX_FOUND OR MMAL_FOUND)
-  set(SOURCES EGLWrapper.cpp)
-
+  set(SOURCES EGLWrapper.cpp
+              EGLNativeTypeFbdev.cpp)
   set(HEADERS EGLNativeType.h
               EGLQuirks.h
-              EGLWrapper.h)
+              EGLWrapper.h
+              EGLNativeTypeFbdev.h)
 endif()
 
 if(OPENGLES_FOUND)
diff -Nur a/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp
--- a/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.cpp	2017-09-29 14:38:15.307260539 -0400
@@ -0,0 +1,183 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include <EGL/egl.h>
+#include "EGLNativeTypeFbdev.h"
+#include "utils/log.h"
+#include <stdlib.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include "utils/StringUtils.h"
+#include "guilib/gui3d.h"
+#include <linux/media.h>
+
+#include <unistd.h>
+
+#include "utils/StringUtils.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CEGLNativeTypeFbdev"
+
+CEGLNativeTypeFbdev::CEGLNativeTypeFbdev()
+{
+  m_iFBHandle = -1;
+  m_nativeWindow  = NULL;
+  m_nativeDisplay = NULL;
+}
+
+CEGLNativeTypeFbdev::~CEGLNativeTypeFbdev()
+{
+}
+
+bool CEGLNativeTypeFbdev::CheckCompatibility()
+{
+  m_iFBHandle = open("/dev/fb0", O_RDWR, 0);
+  if(m_iFBHandle < 0)
+    return false;
+
+  vinfo = new fb_var_screeninfo();
+  if(ioctl(m_iFBHandle, FBIOGET_VSCREENINFO, vinfo) == -1)
+    return false;
+
+  CLog::Log(LOGNOTICE, "%s::%s FBDev device: %d, info.xres %d info.yres %d info.upper_margin %d info.lower_margin %d info.pixclock %d",
+    CLASSNAME, __func__, m_iFBHandle, vinfo->xres, vinfo->yres, vinfo->upper_margin, vinfo->lower_margin, vinfo->pixclock);
+
+  finfo = new fb_fix_screeninfo();
+  if(ioctl(m_iFBHandle, FBIOGET_FSCREENINFO, finfo) == -1)
+    return false;
+
+  return true;
+}
+
+void CEGLNativeTypeFbdev::Initialize()
+{
+  return;
+}
+void CEGLNativeTypeFbdev::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeFbdev::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::CreateNativeWindow()
+{
+  fbdev_window *nativeWindow = new fbdev_window;
+  if (!nativeWindow)
+    return false;
+
+  nativeWindow->width = vinfo->xres;
+  nativeWindow->height = vinfo->yres;
+  m_nativeWindow = nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::DestroyNativeWindow()
+{
+  free(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  res->iWidth = vinfo->xres;
+  res->iHeight = vinfo->yres;
+  res->fRefreshRate = 60;
+  res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen = 0;
+  res->bFullScreen = true;
+  res->iSubtitles = (int)(0.965 * res->iHeight);
+  res->fPixelRatio = 1.0f;
+  res->iScreenWidth = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode = StringUtils::Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate, res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  CLog::Log(LOGNOTICE, "Current resolution: %s", res->strMode.c_str());
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+
+  vinfo->activate = FB_ACTIVATE_NOW;
+
+  if (ioctl(m_iFBHandle, FBIOPUT_VSCREENINFO, vinfo) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - FBIOPUT_VSCREENINFO error", CLASSNAME, __func__);
+    return false;
+  }
+  if (ioctl(m_iFBHandle, FBIOPAN_DISPLAY, vinfo) == -1)
+  {
+    CLog::Log(LOGERROR, "%s::%s - FBIOPAN_DISPLAY error", CLASSNAME, __func__);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "%s::%s width %d height %d refresh %f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
+
+  return true;
+}
+
+bool CEGLNativeTypeFbdev::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  RESOLUTION_INFO res;
+  if (GetNativeResolution(&res) && res.iWidth > 1 && res.iHeight > 1)
+  {
+    resolutions.push_back(res);
+    return true;
+  }
+  return false;
+}
+
+bool CEGLNativeTypeFbdev::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+    GetNativeResolution(res);
+    return true;
+}
+
+bool CEGLNativeTypeFbdev::ShowWindow(bool show)
+{
+  return false;
+}
diff -Nur a/xbmc/windowing/egl/EGLNativeTypeFbdev.h b/xbmc/windowing/egl/EGLNativeTypeFbdev.h
--- a/xbmc/windowing/egl/EGLNativeTypeFbdev.h	1969-12-31 19:00:00.000000000 -0500
+++ b/xbmc/windowing/egl/EGLNativeTypeFbdev.h	2017-09-29 14:38:19.399266227 -0400
@@ -0,0 +1,68 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+#include <linux/fb.h>
+#include <list>
+
+#ifndef _FBDEV_WINDOW_H_
+// Define it right here, since some platforms doesn't has fbdev_window.h at all.
+// This will not make it fail on these platforms badly, since it will fail softly anyway on some other init steps.
+#define _FBDEV_WINDOW_H_
+typedef struct fbdev_window
+{
+  unsigned short width;
+  unsigned short height;
+} fbdev_window;
+#endif
+
+class CEGLNativeTypeFbdev : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeFbdev();
+  virtual ~CEGLNativeTypeFbdev();
+  virtual std::string GetNativeName() const { return "FBDev"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+protected:
+  int m_iFBHandle;
+  fb_var_screeninfo *vinfo;
+  fb_fix_screeninfo *finfo;
+};
diff -Nur a/xbmc/windowing/egl/EGLWrapper.cpp b/xbmc/windowing/egl/EGLWrapper.cpp
--- a/xbmc/windowing/egl/EGLWrapper.cpp	2017-05-24 16:49:32.000000000 -0400
+++ b/xbmc/windowing/egl/EGLWrapper.cpp	2017-09-29 14:38:44.291300018 -0400
@@ -24,9 +24,9 @@
 #include <assert.h>
 #if defined(TARGET_ANDROID)
   #include "EGLNativeTypeAndroid.h"
-#if defined(HAS_LIBAMCODEC)
-  #include "EGLNativeTypeAmlAndroid.h"
-#endif
+  #if defined(HAS_LIBAMCODEC)
+    #include "EGLNativeTypeAmlAndroid.h"
+  #endif
 #endif
 #if defined(TARGET_RASPBERRY_PI)
   #include "EGLNativeTypeRaspberryPI.h"
@@ -35,8 +35,12 @@
   #include "EGLNativeTypeIMX.h"
 #endif
 #if defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
-#include "EGLNativeTypeAmlogic.h"
+  #include "EGLNativeTypeAmlogic.h"
+#endif
+#if defined(TARGET_LINUX) && defined(HAS_HYBRIS)
+  #include "EGLNativeTypeHybris.h"
 #endif
+#include "EGLNativeTypeFbdev.h"
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -101,6 +105,10 @@
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeIMX>(implementation))
 #elif defined(TARGET_LINUX) && defined(HAS_LIBAMCODEC)
       (nativeGuess = CreateEGLNativeType<CEGLNativeTypeAmlogic>(implementation))
+#elif defined(TARGET_LINUX) && defined(HAS_HYBRIS)
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeHybris>(implementation))
+#else
+      (nativeGuess = CreateEGLNativeType<CEGLNativeTypeFbdev>(implementation))
 #endif
       )
   {
@@ -422,4 +430,3 @@
   return eglSurfaceAttrib(display, surface, attribute, value);
 }
 #endif
-
